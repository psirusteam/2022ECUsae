---
title: "Estimación del empleo"
subtitle: "CEPAL - División de Estadísticas Sociales"
author: "Andrés Gutiérrez - Stalyn Guerrero"
format: html
editor: visual
project:
  type: website
  output-dir: docs
---

```{r setup, include=FALSE, message=FALSE, error=FALSE, warning=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
library(printr)
```

### Cargando las librerias requeridas.

```{r}
rm(list =ls())
library(tidyverse)
library(stringr)
library(scales)
library(bayesplot)
library(gridExtra)
library(gridExtra)
library(scales)
library(kableExtra)
library(formatR)
library(patchwork)
library(cmdstanr)
```

### Importando datos

```{r}
source("0Funciones/funciones_mrp.R")
encuesta_mrp <- readRDS("Data/encuesta_multinomial.rds") %>% 
  filter(edad != "1")
censo_mrp <- readRDS("Data/censo_multinomial.rds") %>% 
  filter(edad != "1") 
tasa_desocupados <- readRDS("Data/tasa_desocupacion.rds")

```

### Modelo en stan  

```{r, eval=FALSE}
functions {
  matrix pred_theta(matrix Xp, matrix Zp, int p, matrix beta, matrix u){
  int D1 = rows(Xp);
  real num1[D1, p];
  real den1[D1];
  matrix[D1,p] theta_p;
  
  for(d in 1:D1){
    num1[d, 1] = 1;
    num1[d, 2] = exp(Xp[d, ] * beta[1, ]' + Zp[d, ] * u[1, ]') ;
    num1[d, 3] = exp(Xp[d, ] * beta[2, ]' + Zp[d, ] * u[2, ]') ;
    
    den1[d] = sum(num1[d, ]);
  }
  
  for(d in 1:D1){
    for(i in 2:p){
    theta_p[d, i] = num1[d, i]/den1[d];
    }
    theta_p[d, 1] = 1/den1[d];
   }

  return theta_p  ;
  }
  
}

data {
  int<lower=1> D;    // número de postestrto 
  int<lower=1> D1;   // número de dominios por predesir 
  int<lower=1> P;    // categorías
  int<lower=1> K;  // cantidad de regresores
  int<lower=1> Kz; // cantidad de regresores en Z
  int y[D, P];       // matriz de datos
  matrix[D, K] X; // matriz de covariables
  matrix[D, Kz] Z; // matriz de covariables
  matrix[D1, K] Xp; // matriz de covariables
  matrix[D1, Kz] Zp; // matriz de covariables
}
  

parameters {
  matrix[P-1, K] beta;// matriz de parámetros 
  vector<lower=0>[P-1] sigma_u;       // random effects standard deviations
  // declare L_u to be the Choleski factor of a 2x2 correlation matrix
  cholesky_factor_corr[P-1] L_u;
  matrix[P-1, Kz] z_u;                  
}

transformed parameters {
  simplex[P] theta[D];// vector de parámetros;
  real num[D, P];
  real den[D];
  // this transform random effects so that they have the correlation
  // matrix specified by the correlation matrix above
  matrix[P-1, Kz] u; // random effect matrix
  u = diag_pre_multiply(sigma_u, L_u) * z_u;
  
  for(d in 1:D){
    num[d, 1] = 1;
    num[d, 2] = exp(X[d, ] * beta[1, ]' + Z[d, ] * u[1, ]') ;
    num[d, 3] = exp(X[d, ] * beta[2, ]' + Z[d, ] * u[2, ]') ;
    
    den[d] = sum(num[d, ]);

  }
  for(d in 1:D){
    for(p in 2:P){
    theta[d, p] = num[d, p]/den[d];
    }
    theta[d, 1] = 1/den[d];
  }
}

model {
  L_u ~ lkj_corr_cholesky(1); // LKJ prior for the correlation matrix
  to_vector(z_u) ~ normal(0, 1);
  sigma_u ~ cauchy(0, 50);
  to_vector(beta) ~ normal(0, 100);
 
  for(d in 1:D){
    target += multinomial_lpmf(y[d, ] | theta[d, ]); 
  }
}

  
generated quantities {
  // predict 
  matrix[D1,P] theta_p;// vector de parámetros;
  matrix[2, 2] Omega;
  vector<lower=0>[2] sdcomprobar;
  sdcomprobar[1] = sd(u[1, ]);
  sdcomprobar[2] = sd(u[2, ]);

  Omega = L_u * L_u'; // so that it return the correlation matrix
// predicción 

theta_p = pred_theta(Xp,Zp,P, beta, u) ; 

}


```

### Leyendo el modelo 
```{r}
fit <-
  cmdstan_model(
    stan_file = "Data/modelosStan/Multinivel_multinomial.stan",
    compile = TRUE)
```


    
### Covariables provenientes del censo e imagenes satelitales

```{r}
statelevel_predictors_df <- tasa_desocupados
head(statelevel_predictors_df)
```

### Niveles de agregación para colapsar encuesta

```{r}
byAgrega <-
  grep(
    pattern =  "^(n|pobreza|ingreso|lp|li|fep)",
    x = names(encuesta_mrp),
    invert = TRUE,
    value = TRUE
  )
```

### Creando base con la encuesta agregada

```{r}
encuesta_df_agg <-
  encuesta_mrp %>%
  group_by_at(all_of(byAgrega)) %>%
  summarise(n = n(),
            ingreso = mean(ingreso),
            .groups = "drop") %>% 
   arrange(desc(n))
head(encuesta_df_agg)
```

### Incorporando covariables a la encuesta agregada

```{r}
encuesta_df_agg <- inner_join(encuesta_df_agg, statelevel_predictors_df, by = "depto")
```

### Definiendo el modelo multinivel.

```{r, eval = FALSE}
options(MC.cores=parallel::detectCores())
fit <- stan_lmer(
  ingreso ~ (1 | depto) +
    (1 | edad) +
    (1 | area) +
    (1 | anoest) +
    (1 | etnia) +
    (1 | depto:area) +
    (1 | depto:etnia) +
    (1 | depto:sexo) +
    (1 | depto:edad) +
    (1 | depto:anoest) +
    (1 | area:etnia) +
    (1 | area:sexo) +
    (1 | area:edad) +
    (1 | area:anoest) +
    (1 | etnia:sexo) +
    (1 | etnia:edad) +
    (1 | etnia:anoest) +
    (1 | sexo:edad) +
    (1 | sexo:anoest) +
    (1 | edad:anoest) +
    #    (1 | discapacidad) +
    sexo  + tasa_desocupacion +
      F182013_stable_lights + 
  X2016_crops.coverfraction +
  X2016_urban.coverfraction ,
                  weights = n,
                  data = encuesta_df_agg,
                  verbose = TRUE,
                  chains = 2,
                 iter = 200
                )

```

# Proceso de estimación y predicción

Por tiempo de compilación se realiza el cargue del modelo estimado.

```{r}
fit <- readRDS("Data/fit_ingresos.rds")
fit
```

### Predicción en el censo

```{r}
poststrat_df <- readRDS("Data/poststrat_ingreso.RDS") %>% 
  filter(!anoest %in% c("99", "98") ) %>%
  select(depto:X2016_urban.coverfraction,lp)
poststrat_df %>% arrange(desc(n)) %>% head()
```

### Distribución posterior.

```{r}
epred_mat <- posterior_epred(fit, newdata = poststrat_df, type = "response")
dim(epred_mat)
dim(poststrat_df)
```

### Evaluando las predicciones resultantes

```{r, eval=FALSE}
## validacion de los valores posteriores
summary(rowMeans(epred_mat))
summary(colMeans(epred_mat))

summary(as.numeric(epred_mat))
hist(as.numeric(epred_mat))

length(epred_mat[which(epred_mat < 0)])
```

Igualando valores negativos a cero.

```{r}
epred_mat[(epred_mat < 0)]<-0
length(epred_mat[which(epred_mat < 0)])
```

Obteniendo las lineas de pobreza por cada post-estrato

```{r}
(lp <- encuesta_mrp %>% distinct(area, lp))
```

```{r}
lp <-   poststrat_df %>% mutate(orden = 1:n()) %>%
        select(orden, area) %>%
        left_join(lp, by = "area") %>%
        arrange(orden, desc = FALSE) %>%
        select(lp)
lp <- lp$lp
```

### Ingreso en términos de lineas de pobreza.

```{r}
epred_mat <- t(t(epred_mat)/lp)
```

### Estimación del ingreso medio NACIONAL

```{r}
n_filtered <- poststrat_df$n
mrp_estimates <- epred_mat %*% n_filtered / sum(n_filtered)

data.frame(
  mrp_estimate = mean(mrp_estimates),
  mrp_estimate_se = sd(mrp_estimates)
) 
```

### Estimación para depto == "01" particular.

```{r}
temp <- poststrat_df %>%  mutate(Posi = 1:n())
temp <- filter(temp,depto=="01") %>% select(n,Posi)
n_filtered <- temp$n
temp_epred_mat <- epred_mat[,temp$Posi]
## Estimando el CME
mrp_estimates <- temp_epred_mat %*% n_filtered / sum(n_filtered)

data.frame(
  mrp_estimate = mean(mrp_estimates),
  mrp_estimate_se = sd(mrp_estimates)
)
```

### Estimación para depto == "01" y sexo == "1"

```{r}
temp <- poststrat_df %>%  mutate(Posi = 1:n())
temp <- filter(temp,depto=="01", sexo == "1") %>% select(n,Posi)
n_filtered <- temp$n
temp_epred_mat <- epred_mat[,temp$Posi]
## Estimando el CME
mrp_estimates <- temp_epred_mat %*% n_filtered / sum(n_filtered)

data.frame(
  mrp_estimate = mean(mrp_estimates),
  mrp_estimate_se = sd(mrp_estimates)
)
```

### Estimación para depto == "01", sexo == "1" y area == "1"

```{r}
temp <- poststrat_df %>%  mutate(Posi = 1:n())
temp <- filter(temp,depto=="01", sexo == "1", area == "1") %>% select(n,Posi)
n_filtered <- temp$n
temp_epred_mat <- epred_mat[,temp$Posi]
## Estimando el CME
mrp_estimates <- temp_epred_mat %*% n_filtered / sum(n_filtered)

data.frame(
  mrp_estimate = mean(mrp_estimates),
  mrp_estimate_se = sd(mrp_estimates)
)

```

```{r, eval=TRUE}
# Resultados nacionales ---------------------------------------------------
(mrp_estimate_Ingresolp <-
  Aux_Agregado(poststrat = poststrat_df,
             epredmat = epred_mat,
             byMap = NULL)
)
```

## Automatizando el proceso

### Niveles de Post-estrato

```{r}
byAgrega <-
  grep(
    pattern =  "^(X|F|n|pobreza|ingreso|tasa_desocupacion|epred_mat|depto|lp)",
    x = names(poststrat_df),
    invert = TRUE,
    value = TRUE
  )
byAgrega
```

### Organizando los post-estato

```{r, eval=TRUE}
byAgrega <- t(combn(byAgrega, 2))
byAgrega <- rbind(c("depto","depto" ), byAgrega)
```

### Realizando la estimación

```{r, eval=TRUE}
mrp_ECM <- map(1:nrow(byAgrega), function(ii) {
  Aux_Agregado(poststrat_df,
               epredmat = epred_mat,
               byMap = c("depto", byAgrega[ii,]))
  
})
```

### Asignando nombre las tablas de salida

```{r, eval=TRUE}
nom_tabs <-
  c("depto", apply(byAgrega[-1, ],
                   MARGIN = 1,
                   paste0, collapse = "_"))
names(mrp_ECM) <- nom_tabs
map(mrp_ECM,head)
```

## Algunos mapas resultantes

### Ingreso medio Área - Etnia - Depto

![](Data/images/Ingreso_Area_etnia.png){width="30cm" height="25cm"}

### Ingreso medio Años de escolaridad - Etnia - Depto

![](Data/images/Ingreso_Anoest_etnia.png){width="30cm" height="25cm"}
